<script>
  /***
   * Handle all mark actions for app-page-markup
   * */
  const PageMarkup_MapMixin = subclass =>
  
  class PageMarkup_MapControls extends subclass {
    static get properties() {
      return {
        mapMarkers : {
          type : Object,
          value : function() {
            return {};
          }
        },
        map: {
          type: Object,
          value: null
        },
        bounds: {
          type: Object,
          value: null
        }
      }
    }

    get drawToolOptions() {
      return {
        position: 'topright',
        draw: {
          polyline:false,
          polygon: false,
          circle: false, // Turns off this drawing tool
          rectangle: false,
          marker: {
            icon: ''
          }
        }
      }
    }

    _renderPageOnMap() {
      if ( !this.bounds ) return
      if( this.map ) this.map.remove();

      this.map = L.map(this.$.map, {
        crs: L.CRS.Simple,
        minZoom: -2
      });

      L.imageOverlay(
        this.apiHost+'/media?select=contents&media_id=eq.'+this.selectedPage.media_id,
        this.bounds
      ).addTo(this.map);
      
      this.map.fitBounds(this.bounds);
      setTimeout(function(){
        this.map.zoomIn();
      }.bind(this), 200);
      

      this.marksLayer = new L.FeatureGroup();
      
      this.map.addLayer(this.marksLayer);

      var myIcon = L.divIcon({html: '<app-marker draw-tool-marker></app-marker>'});
      this.drawToolOptions.draw.marker.icon = myIcon;

      L.drawLocal.draw.handlers.marker.tooltip.start = 'Place by the name of the wine';
      this.drawControl = new L.Control.Draw(this.drawToolOptions);

      if( this.selectedPage.editable && !this.selectedPage.completed ) {
        this.helpTextControl = L.control.helpTextControl({ position: 'topright' }).addTo(this.map);
        this.map.addControl(this.drawControl);

        this.map.on(L.Draw.Event.DRAWSTART, this._onDrawToolDrawStart.bind(this));
        this.map.on(L.Draw.Event.CREATED, this._onDrawToolCreated.bind(this));
      }

      this.mapMarkers = {};
      for( var key in this.marks ) {
        if( this.mapMarkers[key] ) continue;
        this.mapMarkers[key] = this._drawMark(this.marks[key]);
      }
      
      if( this.currentState.markId ) {
        this._selectAndShowPopup(this.currentState.markId);
      }

      L.control.adminControl({ position: 'topright' }).addTo(this.map);
      

      // hack
      var controls = this.$.map.querySelectorAll('.leaflet-control, .leaflet-top, .leaflet-bottom');
      for( var i = 0; i < controls.length; i++ ) {
        controls[i].style.zIndex = 500;
      }

      this._updateMapSize();
      this._renderMarkControls();
    }

    /**
     * Global hide/show of all controls
     **/
    _showHideControls(show) {
      if( this.$.carousel ) {
        this.$.carousel.style.display = show ? 'block' : 'none';
      }

      var ele = this.$.map.querySelector('.leaflet-top.leaflet-right');
      if( !ele ) return;
      ele.style.display = show ? 'block' : 'none';
    }

    /**
     * Renders controls based on auth state
     **/
    _renderMarkControls() {
      if( !this.drawControl ) return;
      if( !this.drawControl._container ) return;

      if( !this.userState ) {
        this.drawControl._container.style.display = 'none';
        this.helpTextControl._container.style.display = 'none';
        return 
      } else if ( this.userState.state === 'notLoggedIn' ) {
        this.drawControl._container.style.display = 'none';
        this.helpTextControl._container.style.display = 'none';
        return 
      }

      this.drawControl._container.style.display = 'block';
      this.helpTextControl._container.style.display = 'block';
    }

    _onDrawToolDrawStart(e){
      if( this.userState && this.userState.user.isAnonymous && !this.isAnonymousAlertShow ) {
        alert('Reminder, you are creating marks as an anonymous user.');
        this.isAnonymousAlertShow = true;
      }
    }

    _onDrawToolCreated(e) {
      var type = e.layerType,
          layer = e.layer;
      

      this._updateTempMark(this.selectedPageId, [e.layer._latlng.lng, e.layer._latlng.lat]);


      this.pendingLayer = layer;
      window.location.hash = this.selectedCatalogId + '/' + this.selectedPageId + '/edit';
    }

    _updateMapSize() {
      if( !this.map ) return;

      this.debounce('_updateMapSize', () => {
        this.map.invalidateSize();
      }, 50);
    }

  }
</script>