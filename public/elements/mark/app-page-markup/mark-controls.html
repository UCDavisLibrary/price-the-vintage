<script>
  /***
   * Handle all mark actions for app-page-markup
   * */
  const PageMarkup_MarkMixin = subclass =>
  
  class PageMarkup_MarkControls extends subclass {
    static get properties() {
      return {
        marks : {
          type : Object,
          value : function() {
            return {};
          }
        },
        requestedMarks : {
          type : String,
          value : ''
        }
      }
    }

    _getMarks() {
      return super._getMarks(this.selectedPageId)
                  .then(marks => {
                    marks.forEach(this._onMarksUpdate.bind(this))
                  });
    }

    _onMarksUpdate(e) {
      if( e.pageId !== this.selectedPageId ) return;

      if( e.state !== 'loaded' || e.deleted ) {
        return this._cleanOutMark(e.id);
      }

      this.marks[e.id] = e;

      if( this.mapMarkers[e.id] ) {
        if( e.data.isTemp && this._isMyMark(e) ) {
          return; // don't draw my temp marks
        }

        this.mapMarkers[e.id].setLatLng([e.data.xy[1], e.data.xy[0]]);
      } else {
        this.mapMarkers[e.id] = this._drawMark(e);
      }

      if( this.appState.markId ) {
        if( this.appState.markId === e.id ) {
          this._selectAndShowPopup(e.id);
        } else if( this.mapMarkers[e.id] ) {
          this.mapMarkers[e.id]._icon.style.display = 'none';
        }
      }
    }

    _onMarksApproved(e) {
      if( e.state !== 'loaded' || e.pageId !== this.selectedPageId ) return;

      e.payload.forEach((mark) => {
        if( this.mapMarkers[mark.markId] && this.marksLayer ) {
          this.mapMarkers[mark.markId].removeFromLayer();
        }

        this.marks[mark.markId] = {
          state : 'loaded',
          pageId : mark.pageId,
          id : mark.markId,
          data : mark
        };

        this.mapMarkers[mark.markId] = this._drawMark(this.marks[mark.markId]);
      });
    }

    _removeMarkStart(pageId, markId) {
      this._removeMark(pageId, markId)
           .then(() => this._cleanOutMark(markId))
          .catch(e => {
            alert('Failed to remove mark');
            console.error(e);
          })
    }

    _cleanOutMark(markId) {
      if( this.marks[markId] ) {
        delete this.marks[markId];
      }

      if( this.mapMarkers[markId] ) {
        this.mapMarkers[markId].removeFromLayer();
        delete this.mapMarkers[markId];
      }
    }

    _isMyMark(mark) {
      if( this.userState && (this.userState.user.uid === mark.data.user) ) {
        return true;
      }
      return false;
    }

    _drawMark(mark) {
      if( !this.marksLayer ) return null;

      var marker = document.createElement('app-marker');
      marker.init(mark, this.selectedCatalogId, this.selectedPageId);
      marker.addTo(this.marksLayer);

      return marker;
    }

    _onAddMarkCancel() {
      this._removeTmpMark();
      this.emit('ui-set-location', this.selectedCatalogId + '/' + this.selectedPageId);
    }

    _onDeleteMark(e) {
      var mark = e.detail;
      this._removeMarkStart(this.selectedPageId, mark.id);
      this.emit('ui-set-location', this.selectedCatalogId + '/' + this.selectedPageId);
    }

    /**
     * Called from form
     */
    _onAddMark(e) {
      this._removeTmpMark();
    }

    _removeTmpMark() {
      super._removeTempMark();

      for( var key in this.marks ) {
        if( this.marks[key].data && this.marks[key].data.isTemp ) {
          this._cleanOutMark(key);
        }
      }

      this._selectMarker();
    }

  }
</script>