<script src="DrawToolBehavior.js"></script>

<dom-module id="app-page-markup">
  <template>
    <style include="shared-styles"></style>
    <style>
        :host {
          display: block;
          position: absolute;
          left: 0;
          right: 0;
          top: 0;
          bottom:0;
        }

        .leaflet-div-icon {
          border: none !important;
          background: transparent !important;
        }

        [state="loaded"] {
          position: absolute;
          left: 0;
          right: 0;
          top: 0;
          bottom:0;
        }

        [state="loading"] {
          text-align: center;
          margin-top: 100px;
        }
    </style>

    <div id="map" state="loaded"></div>
    <app-price-form 
        id="priceItem" 
        on-add-mark="_onAddMark" 
        on-edit-mark="_onEditMark"
        on-cancel="_onAddCancel">
      </app-price-form>

    <div state="loading">
      <paper-spinner active></paper-spinner>
    </div>

  </template>
  <script>
    Polymer({

      is: 'app-page-markup',

      properties: {
        selected : {
          type : String,
          value : ''
        },
        active: {
          type: Boolean,
          value: false,
          observer: '_onActive'
        },
        marks : {
          type : Object,
          value : function() {
            return {};
          }
        },
        mapMarkers : {
          type : Object,
          value : function() {
            return {};
          }
        },
        map: {
          type: Object,
          value: null
        },
        bounds: {
          type: Object,
          value: null
        }
      },

      behaviors : [EventBusBehavior, StateToggleBehavior, MarkBehavior],

      ebBind : {
        'selected-catalog-update' : '_onSelectedCatalogUpdate',
        'selected-catalog-page-update' : '_onSelectedCatalogPageUpdate',
        'interested-party-request' : '_onInterestedPartyRequest',
        'catalog-page-marks-update' : '_onPageMarksUpdate',
        'app-state-update' : '_onAppStateUpdate',
        'auth-update' : '_onAuthUpdate'
      },

      ready : function() {
        this._getApi();
        this.ebEmit('get-app-state', {handler: this._onAppStateUpdate.bind(this)});
        this.ebEmit('get-auth-state',{handler: this._onAuthUpdate.bind(this)})
      },

      _getApi : function() {
        this.ebEmit('get-api-host', {
          handler : function(host) {
            this.apiHost = host;
          }.bind(this)
        });
      },

      _onActive : function() {
        if( !this.active ) {
          if( this.addMarker && this.drawTool ) {
            this._removeTmpMark();
            this.addMarker = null;
            this.drawTool.disable();
            this.drawTool.enable();
          }
          return;
        }

        this._onAppStateUpdate();
        this._getPageMarks();
        this._updateMapSize();
      },

      _updateMapSize : function() {
        if( !this.map ) return;

        this.debounce('_updateMapSize', function(){
          this.map.invalidateSize();
        }, 50);
      },

      _onInterestedPartyRequest : function() {
        if( !this.active || !this.selected ) return;

        this.ebEmit(
          'interested-party-response',
          {
            id : this.selected,
            types : ['markup']
          }
        );
      },

      _onSelectedCatalogPageUpdate : function(id) {
        if( this.selected ) this._removeTmpMark();

        this.selected = id;

        this.toggleState('loading');
        this._reset();
        this._getPageMarks();
      },

      _onSelectedCatalogUpdate : function(id) {
        this.catalogId = id;
      },

      _getPageMarks : function() {
        if( !this.selected || !this.active ) return;

        this.ebEmit('get-catalog-page-marks', {
          id: this.selected, 
          handler: this._onPageMarksLoad.bind(this)
        });
      },

      _onPageMarksLoad : function(marks) {
        marks.forEach(this._onPageMarksUpdate.bind(this));
      },

      _onPageMarksUpdate : function(e) {
        if( !this.active || e.pageId !== this.selected ) return;

        if( e.deleted ) {
          if( this.marks[e.id] ) {
            delete this.marks[e.id];
          }
          if( this.mapMarkers[e.id] ) {
            this.marksLayer.removeLayer(this.mapMarkers[e.id]);
            delete this.mapMarkers[e.id];
          }
          return;
        }

        if( e.state !== 'loaded' ) return;

        this.marks[e.id] = e;

        if( this.mapMarkers[e.id] ) {
          if( e.data.isTemp && this._isMyMark(e) ) {
            return; // don't draw my temp marks
          }

          this.mapMarkers[e.id].setLatLng([e.data.xy[1], e.data.xy[0]]);
        } else {
          this.mapMarkers[e.id] = this._drawMark(e);
        }
      },

      _onAuthUpdate : function(e) {
        this.userState = e;
      },

      _reset : function() {
        this.marks = {};
        if( !this.selected ) return;

        var img = new Image();
        img.onload = function() {
          this.bounds = [
            [0,0],
            [img.naturalHeight, img.naturalWidth]
          ];
          
          this.toggleState('loaded');
          this._redraw();
        }.bind(this);

        img.src = this.apiHost+'/pages/'+this.selected+'/image';
      },

      _onAppStateUpdate : function(state) {
        if( state ) {
          this.currentState = state;
        } else {
          state = this.currentState;
        }

        if( !this.active ) return;

        // there is no /edit stub in url, set map mode to default
        if( !state.editingMark ) {
          this._showHideControls(true);
          this.$.priceItem.hide();
          if( this.addMarker && this.marksLayer ) {
            this.marksLayer.removeLayer(this.addMarker);
          }
          this.addMarker = null;
          this._removeTmpMark();

        // the draw tool has fired a create mark event.  This marker has
        // been set as pendingLayer
        } else if( this.pendingLayer ) {
          this._showHideControls(false);
          this.$.priceItem.show(this.pendingLayer._latlng);
          this.marksLayer.addLayer(this.pendingLayer);
          this.addMarker = this.pendingLayer;
          this._selectMarker(this.addMarker);
          this.pendingLayer = null;

        // user has clicked a mark to edit
        } else if( this.pendingEdit ) {
          this._showHideControls(false);
          this.pendingEdit = false;

        // there is a /edit stub in url, but no action required (proly refresh),
        // set to normal (non-edit) mode;
        } else {
          window.location.hash = this.catalogId + '/' + this.selected;
        }
      },

      _isMyMark : function(mark) {
        if( this.userState && (this.userState.user.uid === mark.data.user) ) {
          return true;
        }
        return false;
      },

      _drawMark : function(mark) {
        if( !this.marksLayer ) return;

        var style;
        if( this._isMyMark(mark) ) {
          if( mark.data.isTemp ) return; // don't draw our own tmp marks

          style = this._getMarkBtnStyle();
        } else {
          style = this._getMarkBtnStyle(true);
        }

        var btn = this._getMarkBtn(style, mark);

        var myIcon = L.divIcon({html: btn});
        var marker = L.marker([mark.data.xy[1], mark.data.xy[0]], {icon: myIcon});

        marker.mark = mark;
        marker.on('click', function(){
          if( this.addMarker ) return alert('You must finish or cancel creating new mark.');
          if( mark.data.isTemp ) {
            return alert('User is currently creating new mark.');
          }

          this.$.priceItem.edit(mark);
          this._selectMarker(marker);
          this.pendingEdit = true;
          window.location.hash = this.catalogId + '/' + this.selected + '/edit';
        }.bind(this));

        marker.addTo(this.marksLayer);

        return marker;
      },

      _selectMarker : function(marker) {
        if( this.selectedMarker && this.selectedMarker._icon ) {
          this.selectedMarker._icon.firstChild.style.border = 'none';
        }

        this.selectedMarker = marker;
        if( marker ) {
          this.selectedMarker._icon.firstChild.style.border = '2px solid #FF9800';
        }
      },

      _onAddCancel : function() {
        this._removeTmpMark();
        window.location.hash = this.catalogId + '/' + this.selected;
      },

      _onAddMark : function(e) {
        this._removeTmpMark();
        var data = e.detail;

        this.ebEmit('add-catalog-page-mark', {
          pageId : this.selected,
          mark : data
        });

        window.location.hash = this.catalogId + '/' + this.selected;
      },

      _onEditMark : function(e) {
        var mark = e.detail;

        this.ebEmit('edit-catalog-page-mark', {
          pageId : this.selected,
          markId : mark.id,
          mark : mark.data
        });

        window.location.hash = this.catalogId + '/' + this.selected;
      },

      _removeTmpMark : function() {
        this._selectMarker();
        this.ebEmit('remove-temp-catalog-page-mark', {pageId: this.selected});
      }

    });
  </script>
</dom-module>
